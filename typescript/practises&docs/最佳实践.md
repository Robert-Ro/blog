# Best Practise

## Service 类型化

在业务实践中，前后端需要约定统一的接口规范，并使用格式化的 `Swagger` 或者 `YAPI` 等方式定义接口格式，然后自动生成 `TypeScript` 接口调用代码

- [swagger-codegen](https://swagger.io/tools/swagger-codegen/)
- [swagger-typescript-api](https://github.com/acacode/swagger-typescript-api)
- [auto-service](https://gogoyqj.github.io/auto-service/)
- [yapi-to-typescript](https://github.com/fjc0k/yapi-to-typescript)

GraphQL:

- [GraphQL Code Generator](https://graphql-code-generator.com/)

## TS 在项目中的类型检查方式

`fork-ts-checker-webpack-plugin`: 静态类型检测

- 旧项目：`ts-loader` + `fork-ts-checker-webpack-plugin`
  ts-loader: `transpileOnly: true`, `fork-ts-checker-webpack-plugin`: check type
- 新项目：`babel-loader` + `@babel/preset-typescript`

### `babel-loader` + `@babel/preset-typescript`

处理**类型检查**： //NOTE - 重要！！！

package.json:

```json
{ "type-check": "tsc --watch" }
```

tsconfig.json:

```json
{
  "compilerOptions": {
    "noEmit": true
  }
}
```

## 类型声明

### 隐式`any`

```ts
// 比如我们可以在 global.d.ts 内添加如下所示的 AnyToFix 类型别名定义。且能够满足当前的tsconfig配置中无any的要求
/** 需要替换成更明确的类型 */
type AnyToFix = any
// 并且在条件成熟时，我们可以很方便地筛选出需要类型重构的 func 函数，然后将其参数类型修改为更明确的类型
```

### 类型拓展

[链接](./%E7%B1%BB%E5%9E%8B%E6%8B%93%E5%B1%95%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97.md)

### 命名空间

[命名空间和模块](./%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A8%A1%E5%9D%97.md)

### Triple-slash directives

[三斜线指令](./Triple-slash-directives.md)

## tsconfig

### tsconfig 继承

- 维护一个基础的`@liutsing/tsconfig` package
- 根目录的`tsconfig`继承`@liutsing/tsconfig`
- pnpm 的`monorepo`下, packages 中的包继承根目录中的`tsconfig.json`

## 自动化工具

### 迁移工具

- [ts-migrate](https://github.com/airbnb/ts-migrate), ts-migrate is a tool for helping migrate code to TypeScript. It takes a JavaScript, or a partial TypeScript, project in and gives a compiling TypeScript project out.
