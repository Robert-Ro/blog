# 类型兼容

[Example](./example.ts)

在`TypeScript`中，能不能把一个类型赋值给其他类型是由类型兼容性决定的。

## 特例

- `any` **top type | bottom type**

`any`类型可以赋值给除了`never`之外的任意其他类型，反过来其他类型也可以赋值给`any`, **`any`可以兼容除`never`之外所有的类型，同时也可以被所有的类型兼容**

- `unknown`: **top type**

`unknown`的特性和`never`的特性几乎反过来，即我们不能把`unknown`赋值给除了`any`之外任何其他类型，反过来其他类型都可以赋值给`unknown`

- `never` **bottom type**

`never`的特性是可以赋值给任何其他类型，但反过来不能被其他任何类型（包括`any`在内）赋值

- `void`, `null`, `undefined`: 查看例子
- enum：
  - 其中数字枚举和数字类型相互兼容
  - 不同枚举之间不兼容

## 兼容原则

- 子类型
  - 所有的子类型与它的父类型都兼容
  - 子类型组成的联合类型也可以兼容它们父类型组成的联合类型
- 结构类型

  **如果两个类型的结构一致，则它们是互相兼容的**。比如拥有相同类型的属性、方法的接口类型或类，则可以互相赋值

  特殊场景：两个接口类型或者类，如果其中一个类型不仅拥有另一个类型全部的属性和方法，还包含其他的属性和方法(如同继承自另外一个类型的子类一样)，那么前者可以兼容后者，反之则不行

  > 虽然包含多余属性 id 的变量 O2 可以赋值给变量 O1，但是如果我们直接将一个与变量 O2 完全一样结构的对象字面量赋值给变量 O1，则会提示一个 ts(2322) 类型不兼容的错误 ，这就是对象字面的 `freshness` 特性。

  类兼容性特性: 实际上，在判断两个类是否兼容时，我们可以完全忽略其构造函数及静态属性和方法是否兼容，**只需要比较类实例的属性和方法是否兼容即可**。如果两个类包含私有、受保护的属性和方法，则仅当这些属性和方法源自同一个类，它们才兼容。

- 可继承和可实现

  类型兼容性还决定了接口类型和类是否可以通过 `extends` 继承另外一个接口类型或者类，以及类是否可以通过 `implements` 实现接口。

## 泛型

泛型类型、泛型类的兼容性实际指的是将它们实例化为一个确切的类型后的兼容性。

## 变型

> 判定函数类型兼容性

根据类型之间的子类型关系推断基于它们构造的更复杂类型之间的子类型关系。

比如根据`Dog`类型是`Animal`类型子类型这样的关系，我们可以推断数组类型 `Dog[]`和`Animal[]`、函数类型`() => Dog` 和 `() => Animal` 之间的子类型关系。

在描述类型和基于类型构造的复杂类型之间的关系时，我们可以使用数学中函数的表达方式。比如 `Dog` 类型，我们可以使用 `F(Dog)` 表示构造的复杂类型；`F(Animal)` 表示基于 `Animal` 构造的复杂类型。

这里的变型描述的就是基于 `Dog` 和 `Animal` 之间的子类型关系，从而得出 `F(Dog)` 和 `F(Animal)` 之间的子类型关系的一般性质。而这个性质体现为子类型关系可能会被保持、反转、忽略，因此它可以被划分为**协变**、**逆变**、**双向协变**和**不变**这 4 个专业术语

- 协变(Covariant)
  - 协变也就是说如果 `Dog` 是 `Animal` 的子类型，则 `F(Dog)` 是 `F(Animal)` 的子类型，这意味着在构造的复杂类型中保持了一致的子类型关系，下面举个简单的例子：
  - 实际上接口类型的属性、数组类型、函数返回值的类型都是协变的
- 逆变

  > 类比 Java 里面的类型

  逆变也就是说如果 `Dog` 是 `Animal` 的子类型，则 `F(Dog)` 是 `F(Animal)` 的父类型，这与协变正好反过来。

  - **TypeScript 严格模式下，**函数参数类型**是逆变的**

    原因：如果函数参数类型是协变而不是逆变，那么意味着函数类型 `(param: Dog) => void` 和 `(param: Animal) => void` 是兼容的，这与 `Dog` 和 `Animal` 的兼容一致，所以我们可以用 `(param: Dog) => void` 代替 `(param: Animal) => void` 遍历 `Animal[]` 类型数组。

    但是，这样是不安全的，因为**它不能确保`Animal[]` 数组中的成员都是 `Dog`（可能混入 `Animal` 类型的其他子类型，比如 `Cat`），这就会导致 `(param: Dog) => void` 类型的函数可能接收到 `Cat` 类型的入参**。

- 双向协变

  双向协变也就是说如果 `Dog` 是 `Animal` 的子类型，则 `F(Dog)` 是 `F(Animal)` 的子类型，也是父类型，**既是协变也是逆变**。

  在 _TypeScript 非严格模式下，函数参数类型就是双向协变的_，因此*双向协变并不是一个安全或者有用的特性*。

- 不变

  不变即**只要是不完全一样的类型，它们一定是不兼容的**。也就是说即便 `Dog` 是 `Animal` 的子类型，如果 `F(Dog)` 不是 `F(Animal)` 的子类型，那么 `F(Animal)` 也不是 `F(Dog)` 的子类型。

## 函数类型兼容性规则

- 返回值： 返回值类型兼容，则函数兼容
- 参数类型：在参数个数相同、返回值类型兼容的情况下，函数子类型关系与参数子类型关系是反过来的（逆变）
- 参数个数：在索引位置相同的参数和返回值类型兼容的前提下，函数兼容性取决于参数个数，参数个数少的兼容个数多
- 可选和剩余参数：可选参数可以兼容剩余参数、不可选参数

  剩余参数类型函数定义为其他所有参数类型函数的父类型，并用来约束其他类型函数的类型范围，比如说在泛型中约束函数类型入参的范围

  ## 思考题

  - 参数个数少兼容个数多

    因为个数多的参数函数接口的参数多，对于参数个数少的函数来说，只是多了几个多余参数，不会影响使用

  - 不可选参数和剩余参数互相兼容吗？

    不可选参数和剩余参数是互相兼容的；剩余参数函数可以兼容任意个数参数函数，这是安全的；不可选参数是剩余参数函数((...args: any[]) => any）子类型，是不安全但是便捷的，所以不可选兼容剩余
