# Vue.js 深入浅出 - 最佳实践

## 列表渲染设置 key

## 在`v-if/v-if-else/v-else`中使用 key

如果一组`v-if/v-else`的元素类型相同，最好使用属性`key`，这是因为当状态发生变化时，生成的节点是`v-if/v-else`上其中的一个虚拟节点

默认情况下，Vue.JS 会尽可能高效的更新 DOM，当它在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素溢出，然后在同一个位置添加一个新元素，如果本不相同的元素被识别为相同的元素，则会出现意想不到的副作用(Vue 虚拟 DOM patch 机制)

所以最好为`v-if/v-else`分别添加一个 key

## 路由切换组件不变

基于路由参数渲染的不同组件在相互切换时，组件的生命周期钩子函数并不会重新触发更新，这是因为 Vue-router 会识别处两个路由使用的是同一个组件从而进行复用，并不会重新创建组件，因此组件的生命周期钩子自然也不会被触发。

组件的本质上是一个映射关系(?组件的本质？vue.js， React)，先销毁再重建一个相同的组件会存在很大程度上的性能浪费，复用组件才是正确的选择，但是这意味着组件的生命周期钩子不会再被调用

解决方法：

### 路由导航守卫`beforeRouteUpdate`

> **推荐做法**

该守卫在当前路由改变且组件被复用的时候调用，所以可以在组件内定义路由导航守卫来解决这个问题

组件的生命周期钩子虽然不会重新触发，但是路由提供的`beforeRoutUpdate`守卫可以被触发，因此可以把相关的逻辑写在里面，例如在`beforeRouteUpdate`守卫中发送请求拉取数据、更新状态并重新渲染视图

### 观察`$route`对象的变化

NOTE 监听特定参数的状态变更，避免只监听`$route`对象本身

### 为`router-view`添加属性 key

> 取巧做法，非常暴力

本质上就是利用虚拟 `DOM` 在渲染时通过 `key` 来对比两个节点是否相同的原理

其他应用：

- `tabView`刷新当前页面

## 为所有路由统一添加 query

如果路由上的 query 中有一些是从上游链路上传下来的，那么需要在应用的任何路由中携带，但是所有的跳转路由中都设置一遍会非常麻烦。

### 使用全局路由守卫`beforeEach`

事实上，全局守卫`beforeEach`并不具备修改`query`的能力，但可以在其中使用`next`方法发来中断当前导航，并切换到新导航，添加一些新`query`方法.

> 缺陷：每次切换路由时，全局守卫的`beforeEach`会执行两次,即每次切换路由时其实时切换两次

### 使用函数劫持

> 非常取巧，但效果非常好

## Vuex 与 Pros 的使用边界

- 业务组件使用 Vuex 来维护状态，使用不同组件统一操作 Vuex 中的状态。这样不论是父子组件还是兄弟组件间的通信，都很容易
- 通用组件，使用 props 和事件进行父子组件间的通信(通用组件间不需要兄弟组件进行通信)。这样的话，通用组件会拿到各个业务组件中使用，它要与业务组件进行解耦，所以需要使用 props 来获取状态

## 避免`v-if/v-for`一起使用

- 方案 1：
  `v-for`的数据来自与`v-if`判断条件的计算属性
- 方案 2：
  使用`v-if`包裹`v-for`的列表渲染

## 为组件样式设置作用域

- `scoped`方式 -> 产出带[data-v-[hash]]属性的元素
- `CSS Modules`方式:⭐⭐⭐

## 避免在 scoped 中使用元素选择器

大量的元素和特性组合的选择器会比类和特性组合的选择器慢，所以应该尽可能选用类选择器

> 数据支撑，benchmark？

## 避免隐性的父子组件通信

避免采用借助实例调用方法的方式传递数据，这样就破坏了**props 向下传递，事件向上传递**的约束


------------------------------------------
风格规范

## 单文件组件命名 ⭐⭐
### 文件名大小写
> 编辑器友好
- MyComponent.vue
- my-component.vue
### 基础组件名
应用特定样式和约定的基础组件(也就是展示类的、无逻辑的或无状态的组件)应该全部以一个特定的**前缀**开头，比如`Base`、`App`或`V`,这些组件可以为你的应用奠定一致的基础样式和行为。他们可能只包括：
- HTML元素
- 其他基础组件
- 第三方UI组件库

这样做的好处如下：
- 编辑器中以字母排序，方便更快查找识别
- 因为组件频繁被使用，所以可能会把它们放到全局而不是各处分别导入它们，相同的前缀方便`webpack`工作
### 单例组件名
只拥有单个活跃实例的组件以`The`前缀命名，以示唯一性。?
- 每个页面只使用一次
- 用于不接受任何prop

### 紧密耦合的组件名

## 自闭合组件

## prop 名的大小写

## 多个特性的元素

## 模板中的简单的表达式

## 简单的计算属性

## 指令缩写

## 良好的代码顺序

##
