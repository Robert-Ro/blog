# Pactch

> patch本身就有补丁、修补等意思

虚拟DOM最核心的就是patch，它可以将`vnode`渲染成真实的DOM。

渲染真实DOM时，并不是暴力覆盖原有DOM，而是比对新旧两个`vnode`之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新。

之所以这么做，是因为DOM操作的执行速度(跟底层C++)远不如JavaScript的运算速度快，因此把大量的DOM操作搬运到JavaScript中，使用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提升性能。本质上是用JavaScript的运算速度来替换DOM操作的执行成本，所以才有了虚拟DOM。

> 虚拟DOM是对真实DOM做了一层抽象，拓宽了前端的应用场景

## patch介绍

对比两个`vnode`之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的是修改DOM节点，也可以理解为渲染视图。patch不是暴力替换节点，而是在现有的DOM上进行修改来达到渲染视图的目的。对现有DOM进行修改有三种方法：
* 创建新的节点
  + 什么情况下创建节点，插入到什么位置
* 删除已经废弃的节点
  + 什么情况下删除节点，删除哪个节点
* 修改需要更新的节点
  + 什么情况下修改节点，修改哪个节点

  我们的最终目的是渲染视图，所以可以发现渲染视图的标准是以`vnode`(使用最新状态创建的`vnode`)来渲染而不是以`oldVnode`(上一次渲染的DOM所创建的`vnode`)，也就是说，当`oldVnode`与`vnode`不一致的时候，以`vnode`来渲染视图。

### 新增节点

> 讨论在什么情况下需要新增节点

之所以讨论什么情况下需要新增节点，本质上是为了使用JavaScript的计算成本来换取DOM的操作成本。如果一个节点已经存在与DOM中，那就不再需要重新创建一个同样的节点去替换已经存在的节点。事实上，只有那些因为状态的改变而新增的节点在DOM中并不存在时，才需要创建一个节点并插入到视图中去。

#### 场景

* 当`oldVnode`不存在而`vnode`存在时，就需要使用`vnode`生成真实的DOM元素并将其插入到视图中。通常发生在首次渲染中，只有首次渲染时，`oldVnode`才是不存在的。
* 当odlVnode与`vnode`完全不是同一个节点时，就需要使用`vnode`生成真实的DOM并将其插入到视图中。

### 删除节点

当`oldVnode`以`vnode`完全不是同一个节点时，在DOM中需要使用`vnode`创建的新节点替换`oldVnode`所对应的旧节点，替换过程是将新创建的DOM节点插入到旧节点的旁边，然后再将旧节点删除

### 更新节点

除了上述的场景外，另一个更常见的场景是新旧两个节点是同一个节点，这时就需要对这两个节点进行细致的比对，然后对`oldVnode`在视图中所对应的真实节点进行更新。

> 需要根据节点的不同类型做不同的处理

### 小结

* 当`oldVnode`不存在时，直接使用`vnode`渲染视图；
* 当`oldVnode`和`vnode`都存在但并不是同一个节点，使用`vnode`创建的DOM元素来替换就的DOM元素；
* 当`oldVnode`和`vnode`是同一个节点是，就需要更详细的对比操作对真实的DOM节点进行更新。

## 创建节点

> 在什么情况下创建元素并将元素渲染到视图。

* 创建DOM元素所需信息保存在`vnode`中
* `vnode`有不同的类型，需要根据`vnode`的类型来创建出相同类型的DOM元素，然后将元素插入到视图中

事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、文本节点和注释节点。

* 创建：根据节点的`tag`，调用`createElement`生成真实的元素节点
* 插入：调用`appendChild`插入到指定的父节点中(如果父节点已经渲染到视图中，那么把元素插入它的下面将会自动将元素渲染到视图中)
* 还有一个步骤：元素节点通常会有子节点，因此这就存在一个递归的过程来创建子节点。`vnode`中的`children`属性保存了创建子节点所需的所有信息。创建子节点时，子节点的父节点就是刚创建出的这个节点，所以子节点被创建后，会插入到当前节点的下面。当所有的子节点都创建并插入到当前节点之中，会把当前节点插入到它的父节点下面。如果父节点已经渲染到视图中，那么将当前节点插入进去后，会将当前节点(包括其子节点)渲染到视图中。

如果 `vnode` 不存在 `tag` 属性时，它可能时文本节点或注释节点(可根据 `isComment` 来判断)
* 文本节点：`createTextNode`(`document.createTextNode`)
* 注释节点：`createComment`(`document.createComment`)

## 删除节点

删除节点的过程比较简单，调用 `removeVnodes` / `removeVnoed` 方法( `el.removeChild` )

```js
function removeVnodes(`vnode`s, startIdx, endIdx) {

    for (; startIdx < endIdx; ++startIdx) {
        const ch = `vnode`s[startIdx]
        if (isDef(ch)) {
            removeVnode(ch.elm)
        }
    }
}
/**
 * nodeOps是对节点操作的封装
 * 不直接调用parent.removeChild(child)是考虑到跨平台渲染的问题
 */
const nodeOps = {
    removeChild(node, child) {
        node.removeChild(child)
    }
}

function removeChild(el) {
    const parent = nodeOps.parentNode(el)
    if (isDef(parent)) {
        nodeOps.removeChild(parent, el)
    }
}
```

跨平台渲染的本质是在设计框架的时候，要让框架的渲染机制和DOM解耦，只需要把框架更新DOM时的节点操作进行封装，就可以进行跨平台渲染，在不同平台调用节点的操作
。

节点操作的封装看成渲染引擎。那么将这些渲染引起所提供的节点操作的api和框架的运行时对接一下，就可以实现将框架中的代码进行原生渲染的目的。

## 更新节点

> 详细过程

### 静态节点

更新节点时，需要判断新旧两个节点是否为静态节点，如果是，就不需要进行更新操作，可以直接跳过更新节点的过程。

静态节点指的是那些一旦渲染到界面上之后，无论日后状态如何变化，都不会发生任何变化的节点。

#### 新虚拟节点有文本属性

当虚拟节点不是静态节点，并且有不同的属性时，要以`vnode`为准来更新视图。根据`vnode`是否含有text属性，更新节点分为两种情况：
* 新生成的`vnode`有text属性，那么无论之前旧节点的子节点是什么，直接调用`setTextContent`方法(`node.textContent = 'xxx'`), 如果`oldVnode`也是文本节点，且和新节点的文本相同，就不需要执行`setTextContent`方法。

#### 新虚拟节点无文本属性

无文本属性-> 元素节点(便有了属性、children? 等)
1. 有children的情况
  + 旧虚拟节点有children属性：children之间需要一一进行比较，更新操作：移动子节点的位置，删除或新增某个子节点
  + 旧虚拟节点无children属性：旧节点要么是一个空标签，要么是有文本的文本节点
    - 文本节点：清空文本，变为空标签，再将新虚拟节点中的children挨个生成真实的DOM元素节点并将其插入到视图中的DOM节点下面

2. 无children的情况
  新创建的节点既无text属性也无children属性时，这说明新创建的节点就是一个空节点，它下面既无文本又无子节点。如果旧节点有子节点，就删除子节点；有文本节点，就删除文本。有什么删除什么，最后达到空标签的目的。

### 小结

![更新节点的逻辑](../../../assets/image/20200924094241982.png)

![源码真实实现](../../../assets/image/20200924140156934.png)
