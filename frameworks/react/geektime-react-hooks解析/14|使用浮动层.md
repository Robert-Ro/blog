# 14|使用浮动层.md

浮动层对话框使用难点：

- 对话框需要在父组件中声明，才能在子组件中控制其是否显示；
- 给对话框的参数只能通过 props 传入，这意味着所有的状态管理都需要在更高级别的组件上。实际上呢，这个对话框的参数可能只在子组件中才会维护，这时就需要利用自定义事件将参数回传，非常繁琐。

## 案例导入：处理对话框的误区

一个常见的需求场景：

```jsx
function MainLayout() {
  const [modalVisible, setModalVisible] = useState(false)
  const [user, setUser] = useState(null)
  const showUserModal = (user) => {
    setModalVisible(true)
    setUser(user)
  }
  return (
    <div className="main-layout">
      <Sider onNewUser={showUserModal} />
      <UserList onEditUser={(user) => showUserModal(user)} />
      <UserInfoModal
        visible={modalVisible}
        user={user}
      />
    </div>
  )
}
```

问题分析：

1. 语义隔离不准确。MainLayout 这个组件只做布局的事情，而不应该有其他的业务逻辑。但是这里，加入了用户信息处理的逻辑，就让本不相关的两块功能产生了依赖。而且，如果要增加另外一个对话框，那意味着又要在 Layout 上增加新的业务逻辑了。这样的话，代码很快会变得臃肿，且难以理解和维护
2. 难以拓展。现在我们只是在 MainLayout 下面的两个组件共享了对话框，但是如果和 MainLayout 同级的组件也要访问这个对话框呢？又或者，MainLayout 下面的某个深层次的孙子组件也要能显示同一个对话框呢？

这样处理的话，就会非常麻烦。前者意味着代码需要重构，继续提升到父组件；有着意味着业务逻辑处理更加复杂，需要通过层层的自定义事件回调来完成。

这些问题的本质就是：**一个实现业务逻辑的 Modal 究竟应该在哪个组件中去声明？又该怎么和它进行交互呢?**

## 思路：使用全局状态管理所有的对话框

> 在一个比较大型的项目中，如何用一个统一的方式去管理对话框，从而让对话框相关的业务逻辑能够更加模块化，以及和其他业务逻辑进行解耦。

### 对话框的本质

对话框的本质：独立于其他界面的一个窗口，用于完成一个独立的功能。

从视觉的角度出发，就会发现在使用对话框的时候，完全不关心这个对话框是从哪个具体的组件中弹出来，而只会关心对话框本身的内容。

对话框应该独立于各个组件之外的。虽然很可能在一开始这个对话框的实现和某个组件有非常高的相关度，但是在整个应用的不断开发和演进过程中，是很可能不断变化的。

所以，在定义一个对话框的时候，其定位基本会等于定义一个具有唯一 URL 路径的页面。前者只是由弹出层实现，后者是页面的切换。

以思考页面级别的 UI 切换的思路出发，就是将对话框全局化，然后通过一个全局的机制来管理这些对话。

### 实现：创建 NiceModal 组件和相关 API

首先要考虑的便是如何管理全局状态, 使用 redux 处理

为了让 Redux 的 action 使用起来更方便，我们可以定义一个 useNiceModal 这样的 Hook，在其内部封装对 Store 的操作，从而实现对话框状态管理的逻辑重用，并以更友好的方式暴露给用户

### 处理对话框返回值

如果说对话框和页面这两种 UI 模式基本上是一致的，都是独立窗口完成独立逻辑。但是在用户交互上，却是有一定的差别，

- 对话框可能需要返回值给调用者；
- 而页面切换一般不会关心页面执行的结果是什么。

使用`Promise`来处理，`useNiceModal`返回一个`resolve`，在合适的时机去`resolve`

## 思考题

在本文中，我们使用的是 Redux 来管理所有对话框的所有状态。但有时候你的项目并不一定使用了 Redux，那么我们其实也
可以使用 Context 来管理对话框的全局状态。那么请你思考一下，如果基于 Context ，应该如何实现 NiceModal 呢？
