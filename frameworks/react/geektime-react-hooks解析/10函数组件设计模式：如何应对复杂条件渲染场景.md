# 10 ｜函数组件设计模式：如何应对复杂条件渲染场景.pdf

> 所谓设计模式，就是针对特定场景，提供一种公认的最佳实践。在前面的课程中，我们已经提到了不少模式，比如保证状态的唯一数据源，语义化的拆分复杂组件，等等。熟练掌握这些模式，可以让我们的代码更加简洁直观。

1. 一个和 `Hooks` 相关，用于解决 `Hooks` 无法在条件语句中执行带来的一些难题；
2. 另一个则是经典的 `render props` 模式，用于实现 `UI` 逻辑的重用。

## 容器模式：实现按条件执行 `Hooks`

如果在当前函数中添加条件判断的话，会触发`eslint-react-hooks`相关的校验错误，且 `React Hooks` 只能在顶级作用域使用，而不能放在**条件判断**、**循环**等语句中，同时也不能在可能的 `return` 语句之后执行。换句话说，`Hooks` 必须按顺序被执行到

> 原理：`hooks`链式数据结构。
> `React query` 中的`enable`也是利用这样来处理

具体做法就是**把条件判断的结果放到两个组件之中，确保真正 `render UI` 的组件收到的所有属性都是有值的**。

```js
// 定义一个容器组件用于封装真正的 UserInfoModal
export default function UserInfoModalWrapper({
  visible,
  ...rest // 使用 rest 获取除了 visible 之外的属性
}) {
  // 如果对话框不显示，则不 render 任何内容
  if (!visible) return null
  // 否则真正执行对话框的组件逻辑
  return (
    <UserInfoModal
      visible
      {...rest}
    />
  )
}
```

> // NOTE 写一个 `hooks`，接收参数，返回倒计时，当条件为 `true` 开始倒计时
> // NOTE 使用这种 `modal` 的方式

## 使用 render props 模式重用 UI 逻辑

> 传递一个 `render function`，子组件的显示 `UI` 基于传递过来的 `render function` 来决定
> 与`<>{children}</>`处理方式的区别
> `Vue` 中的 `slot` 区别和对比

把 `render` 函数作为属性传递给某个组件，由这个组件去执行这个函数从而 `render` 实际的内容

在 `class` 组件时期，`render props` 和 `HOC`(高阶组件)两种模式可以说是进行逻辑重用的两把利器。但是实际上，`HOC` 的所有场景都可以用 `render props` 来实现。

在如今的函数组件的情况下，`Hooks` 有一个局限，那就是只能用作数据逻辑的重用，而一旦涉及 `UI` 表现逻辑的重用，就有些力不从心，而这正是 `render props` 擅长的地方。所以，即使有了 `Hooks`，我们也要掌握 `render props` 这个设计模式的用法。

当然，我们完全也可以使用其它的属性名字，而不是 `children`。我们只需要把这个 `render` 函数作为属性传递给组件就可
以了，这也正是 `render props` 这个名字的由来。
### 项目举例
#### 例1
需求：展示一个列表，超过一定数量，则把多余的折叠起来，通过一个弹窗去显示。

分析：
- 相同点：超过一定数量时，则显示一个"更多..."的文字，鼠标移上去，弹出一个框，用于显示其他的数据
- 不同点：每一个列表项如何显示，是在使用的时候决定的

这种UI逻辑重用需求的场景下，我们无法通过Hooks实现，而是需要通过render props这个设计模式

