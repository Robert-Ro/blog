# 04 ｜内置 Hooks（2）：为什么要避免重复定义回调函数

## useCallback：缓存回调函数

在 React 函数组件中，每一次 UI 的变化，都是通过重新执行整个函数来完成的，这和传统的 Class 组件有很大区别：函数组
件中并没有一个直接的方式在多次渲染之间维持一个状态。

每次重新执行都会创建一个新的事件处理函数， 即使函数中的某个状态没有变化。

创建一个新的事件处理函数，虽然不影响结果的正确性，但其实是没必要的。

- 增加系统的开销
- 创建新函数的方式会让接收事件处理函数的组件，需要重新渲染(属性变更了)

函数签名：

```js
useCallback(fn, deps)
```

这里 fn 是定义的回调函数，deps 是依赖的变量数组。只有当某个依赖变量发生变化时，才会重新声明 fn 这个回调函数

## useMemo：缓存计算的结果

函数签名：

```js
useMemo(fn, deps)
```

这里的 fn 是产生所需数据的一个计算函数。通常来说，fn 会使用 deps 中声明的一些变量来生成一个结果，用来渲染出最终的 UI。

如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算。

好处：避免子组件的重复渲染

useCallback: 也可以用 useMemo 来实现

建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到。

## useRef：在多次渲染之间共享数据

函数签名：

```js
const myRefContainer = useRef(initialValue)
```

- 对象引用：计时器、dom 节点的引用
- 保存的数据一般与 UI 渲染无关

## useContext：定义全局状态

> 跨层次、同级组件通信

函数签名：

```js
const value = useContext(MyContext)
```

Q: Context 看上去就是一个全局的数据，为什么要设计这样一个复杂的机制，而不是直接用一个全
局的变量去保存数据呢？
A: 其实很简单，就是为了能够进行数据的绑定。当这个 Context 的数据发生变化时，使用这个数据的组件就**能够自动刷新**。但如果没有 Context，而是使用一个简单的全局变量，就很难去实现了。

## Q&A

- Q: 关于子组件 props 不变，可以减少不必要的渲染问题，不是特别理解。似乎只要父组件重新渲染子组件必然重新渲染，是内部有什么别的地方优化么？
  2021-06-1011:32
- A: 好问题，之前在 Class 组件中可以把组件继承自 React.PureComponent，从而 props 没变就不重新 render。现在函数组件没有 PureComponent 的概念，但是提供了 React.memo (https://reactjs.org/docs/react-api.html#reactmemo) 这样一个高阶组件，可以让任何 React 组件都能在 props 不变时就不重新渲染。所以，在开发过程中，即使现在没有使用 React.memo，但是使用 useCallback 或者 useMemo 至少可以为性能优化提供一个基础。
- Q: useRef 如果只是用来 在多次渲染之间共享数据，是不是直接可以把变量定义到组件外面，这样也可以达到目的，感觉还更方便一点呢
- A: useRef 可以保证这个变量只在当前组件的实例中使用。也就是说，_如果一个组件页面上有多个实例_，比如：`<div><Timer /><Timer /></div>`,那么组件外的普通变量是被 Timer 共享的，就会产生问题。
- Q: 是任何场景 函数都用 useCallback 包裹吗？那种轻量的函数是不是不需要？
- A: 确实不是，useCallback 可以减少不必要的渲染，主要体现在将回调函数作为属性传给某个组件。如果每次都不一样就会造成组件的重新渲染。但是如果你确定子组件多次渲染也没有太大问题，特别是原生的组件，比如 button，那么不用 useCallback 也问题不大。所以这和子组件的实现相关，和函数是否轻量无关。但是比较好的实践是都 useCallback
- Q: useCallback 依赖是空数组表示什么？
- A: 没有意义，相当于每次都创建一个新的函数
- Q: 个问题想问下，关于 useMemo，文档说的是性能优化的保证，也就是涉及到大量计算的时候可以使用，因为依赖项的比较本身也是有开销的。那如果我就只是很简单的计算，或者就只是返回一个固定的对象，有必要使用吗
- A: 依赖项比较大的性能开销可以忽略。useMemo 其实除了解决自身计算的性能问题之外，还有就是可以避免 接收这个数据的组件过多的重新渲染，以及依赖这个数据的其它 hooks 多余的计算。所以即使简单的计算，最好也是用 useMemo
- Q: `const handleIncrement = useCallback(() => setCount(count + 1), [count]);` `const handleIncrement = useCallback(() => setCount(q => q + 1), []);`后者只创建了一次函数，但是又调用了多次在 setCount 的回调函数,前者只会在 count 变化的时候创建新的回调函数
- A: 严格来说，后者确实优于前者，因为后者在 count 变化时不会创建新的 handleIncrement 这样的 callback，这样接收这个属性的组件就不需要重新刷新。但是对于简单的场景，可以忽略这种差异。
- Q: useCallback、useMemo 和 useEffect 的依赖机制一样吗？都是浅比较吗？
- A: 是的，所以依赖比较都是浅比较
