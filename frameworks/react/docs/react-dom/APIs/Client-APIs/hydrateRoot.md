# hydrateRoot

`hydrateRoot` lets you display React components inside a browser DOM node whose HTML content was **previously generated** by [`react-dom/server`.](/reference/react-dom/server)
`hydrateRoot`允许你在浏览器的 DOM 节点中显示 React 组件，这些节点的 HTML 内容之前是由[`react-dom/server`](/reference/react-dom/server)生成的。

```js
const root = hydrateRoot(domNode, reactNode, options?)
```

---

## Reference

### `hydrateRoot(domNode, reactNode, options?)`

Call `hydrateRoot` to “attach” React to existing HTML that was already rendered by React in a server environment.

```js
import { hydrateRoot } from 'react-dom/client'

const domNode = document.getElementById('root')
const root = hydrateRoot(domNode, reactNode)
```

React will attach to the HTML that exists inside the `domNode`, and take over managing the DOM inside it. An app fully built with React will usually only have one `hydrateRoot` call with its root component.

[See more examples below.](#usage)

#### Parameters

- `domNode`: A [DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element) that was rendered as the root element on the server.

- `reactNode`: The "React node" used to render the existing HTML. This will usually be a piece of JSX like `<App />` which was rendered with a `ReactDOM Server` method such as `renderToPipeableStream(<App />)`.

- **optional** `options`: An object with options for this React root.

  - **optional** `onRecoverableError`: Callback called when React automatically recovers from errors.
  - **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.

#### Returns

`hydrateRoot` returns an object with two methods: [`render`](#root-render) and [`unmount`.](#root-unmount)

#### Caveats

- `hydrateRoot()` expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them. `hydrateRoot()`期望渲染的内容与服务器端渲染的内容完全相同。你应该将不匹配视为错误并加以修复。
- In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.在开发模式下，React 会在水合过程中警告不匹配情况。如果存在不匹配，不能保证属性差异会被修复。出于性能原因，这很重要，因为在大多数应用中，不匹配是很少见的，因此验证所有标记将是代价高昂的。
- You'll likely have only one `hydrateRoot` call in your app. If you use a framework, it might do this call for you. 你的应用程序可能只有一个`hydrateRoot`调用。如果你使用一个框架，它可能会为你执行这个调用。
- If your app is client-rendered with no HTML rendered already, using `hydrateRoot()` is not supported. Use [`createRoot()`](/reference/react-dom/client/createRoot) instead. 如果你的应用是在客户端渲染的，而没有已经渲染的 HTML，那么不支持使用`hydrateRoot()`。请使用[`createRoot()`](/reference/react-dom/client/createRoot)。

---

### `root.render(reactNode)`

Call `root.render` to update a React component inside a hydrated React root for a browser DOM element.

```js
root.render(<App />)
```

React will update `<App />` in the hydrated `root`.

[See more examples below.](#usage)

#### Parameters

- `reactNode`: A "React node" that you want to update. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [`createElement()`](/reference/react/createElement), a string, a number, `null`, or `undefined`.

#### Returns

`root.render` returns `undefined`.

#### Caveats

- If you call `root.render` before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.

---

### `root.unmount()`

Call `root.unmount` to destroy a rendered tree inside a React root.

```js
root.unmount()
```

An app fully built with React will usually not have any calls to `root.unmount`.

This is mostly useful if your React root's DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to "stop" managing the removed root's content by calling `root.unmount`. Otherwise, the components inside the removed root won't clean up and free up resources like subscriptions.

Calling `root.unmount` will unmount all the components in the root and "detach" React from the root DOM node, including removing any event handlers or state in the tree.

#### Parameters

`root.unmount` does not accept any parameters.

#### Returns

`root.unmount` returns `undefined`.

#### Caveats

- Calling `root.unmount` will unmount all the components in the tree and "detach" React from the root DOM node.

- Once you call `root.unmount` you cannot call `root.render` again on the root. Attempting to call `root.render` on an unmounted root will throw a "Cannot update an unmounted root" error.

---

## Usage

### Hydrating server-rendered HTML

If your app's HTML was generated by [`react-dom/server`](/reference/react-dom/client/createRoot), you need to _hydrate_ it on the client.

```js
import { hydrateRoot } from 'react-dom/client'

hydrateRoot(document.getElementById('root'), <App />)
```

This will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.

To hydrate your app, React will "attach" your components' logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.

<Sandpack>

```html
<!--
  HTML content inside <div id="root">...</div>
  was generated from App by react-dom/server.
-->
<div id="root">
  <h1>Hello, world!</h1>
  <button>
    You clicked me
    <!-- -->0<!-- -->
    times
  </button>
</div>
```

```js
import './styles.css'
import { hydrateRoot } from 'react-dom/client'
import App from './App.js'

hydrateRoot(document.getElementById('root'), <App />)
```

```js
import { useState } from 'react'

export default function App() {
  return (
    <>
      <h1>Hello, world!</h1>
      <Counter />
    </>
  )
}

function Counter() {
  const [count, setCount] = useState(0)
  return <button onClick={() => setCount(count + 1)}>You clicked me {count} times</button>
}
```

</Sandpack>

You shouldn't need to call `hydrateRoot` again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will [use state](/reference/react/useState) instead.

<Pitfall>

The React tree you pass to `hydrateRoot` needs to produce **the same output** as it did on the server.
传递给`hydrateRoot`的 React 树需要产生**与服务器端相同的输出**。

This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.
这对用户体验非常重要。用户在 JavaScript 代码加载之前会花一些时间查看服务器生成的 HTML。服务器渲染通过显示其输出的 HTML 快照来制造应用程序加载更快的假象。突然显示不同的内容会破坏这种假象。这就是为什么服务器渲染输出必须与客户端上的初始渲染输出匹配。

The most common causes leading to hydration errors include 导致水合错误的最常见原因包括：

- Extra whitespace (like newlines) around the React-generated HTML inside the root node.根节点内部 React 生成的 HTML 周围有额外的空白（比如换行符）。
- Using checks like `typeof window !== 'undefined'` in your rendering logic.在渲染逻辑中使用`typeof window !== 'undefined'`这样的检查。
- Using browser-only APIs like [`window.matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your rendering logic. 在渲染逻辑中使用仅限于浏览器的 API，比如[`window.matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)。
- Rendering different data on the server and the client.在服务器端和客户端上渲染不同的数据。

React recovers from some hydration errors, but **you must fix them like other bugs.** In the best case, they'll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements. React 会从一些水合错误中恢复，但**你必须像处理其他错误一样修复它们**。在最好的情况下，它们会导致减速；在最坏的情况下，事件处理程序可能会附加到错误的元素上。

</Pitfall>

---

### Hydrating an entire document

Apps fully built with React can render the entire document as JSX, including the [`<html>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html) tag:

```js {3,13}
function App() {
  return (
    <html>
      <head>
        <meta charSet="utf-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1"
        />
        <link
          rel="stylesheet"
          href="/styles.css"
        ></link>
        <title>My app</title>
      </head>
      <body>
        <Router />
      </body>
    </html>
  )
}
```

To hydrate the entire document, pass the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/Window/document) global as the first argument to `hydrateRoot`:

```js {4}
import { hydrateRoot } from 'react-dom/client'
import App from './App.js'

hydrateRoot(document, <App />)
```

---

### Suppressing unavoidable hydration mismatch errors

If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.

To silence hydration warnings on an element, add `suppressHydrationWarning={true}`:
可以在元素上添加`suppressHydrationWarning={true}`来消除水合警告

<Sandpack>

```html
<!--
  HTML content inside <div id="root">...</div>
  was generated from App by react-dom/server.
-->
<div id="root">
  <h1>
    Current Date:
    <!-- -->01/01/2020
  </h1>
</div>
```

```js src/index.js
import './styles.css'
import { hydrateRoot } from 'react-dom/client'
import App from './App.js'

hydrateRoot(document.getElementById('root'), <App />)
```

```js
export default function App() {
  return <h1 suppressHydrationWarning={true}>Current Date: {new Date().toLocaleDateString()}</h1>
}
```

</Sandpack>

This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. Unless it’s text content, React still won’t attempt to patch it up, so it may remain inconsistent until future updates.

---

### Handling different client and server content

If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a [state variable](/reference/react/useState) like `isClient`, which you can set to `true` in an [Effect](/reference/react/useEffect):

<Sandpack>

```html
<!--
  HTML content inside <div id="root">...</div>
  was generated from App by react-dom/server.
-->
<div id="root"><h1>Is Server</h1></div>
```

```js
import './styles.css'
import { hydrateRoot } from 'react-dom/client'
import App from './App.js'

hydrateRoot(document.getElementById('root'), <App />)
```

```js
import { useState, useEffect } from 'react'

export default function App() {
  const [isClient, setIsClient] = useState(false)

  useEffect(() => {
    setIsClient(true)
  }, [])

  return <h1>{isClient ? 'Is Client' : 'Is Server'}</h1>
}
```

</Sandpack>

This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.

<Pitfall>

This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.
要消除在服务器端和客户端之间不可避免的单个元素属性或文本内容的不同（例如，时间戳）导致的水合不匹配警告，你可以在元素上添加`suppressHydrationWarning={true}`来消除水合警告。

</Pitfall>

---

### Updating a hydrated root component✨✨✨

After the root has finished hydrating, you can call [`root.render`](#root-render) to update the root React component. **Unlike with [`createRoot`](/reference/react-dom/client/createRoot), you don't usually need to do this because the initial content was already rendered as HTML.**水合完成后，你可以调用[`root.render`](#root-render)来更新根 React 组件。**与[`createRoot`](/reference/react-dom/client/createRoot)不同，通常情况下你不需要这样做，因为初始内容已经作为 HTML 渲染出来了。**

If you call `root.render` at some point after hydration, and the component tree structure matches up with what was previously rendered, React will [preserve the state.](/learn/preserving-and-resetting-state) Notice how you can type in the input, which means that the updates from repeated `render` calls every second in this example are not destructive:如果在水合后的某个时刻调用`root.render`，并且组件树结构与先前渲染的内容匹配，React 会[保留状态](/learn/preserving-and-resetting-state)。请注意你可以在输入框中输入文字，这意味着在这个例子中每秒重复调用`render`并不会破坏输入框中的内容。

<Sandpack>

```html
<!--
  All HTML content inside <div id="root">...</div> was
  generated by rendering <App /> with react-dom/server.
-->
<div id="root">
  <h1>
    Hello, world!
    <!-- -->0
  </h1>
  <input placeholder="Type something here" />
</div>
```

```js
import { hydrateRoot } from 'react-dom/client'
import './styles.css'
import App from './App.js'

const root = hydrateRoot(document.getElementById('root'), <App counter={0} />)

let i = 0
setInterval(() => {
  root.render(<App counter={i} />)
  i++
}, 1000)
```

```js
export default function App({ counter }) {
  return (
    <>
      <h1>Hello, world! {counter}</h1>
      <input placeholder="Type something here" />
    </>
  )
}
```

</Sandpack>

It is uncommon to call [`root.render`](#root-render) on a hydrated root. Usually, you'll [update state](/reference/react/useState) inside one of the components instead.在已经完成水合的根上调用`root.render`是不常见的。通常情况下，你会在组件内部更新状态。
