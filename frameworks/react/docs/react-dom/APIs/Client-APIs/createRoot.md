# createRoot

`createRoot` lets you create a root to display React components inside a browser DOM node.创建一个展示 `react` 组件的根节点，挂载到浏览器内部节点上

```js
const root = createRoot(domNode, options?)
```

## Reference

### `createRoot(domNode, options?)`

Call `createRoot` to create a React root for displaying content inside a browser DOM element.

```js
import { createRoot } from 'react-dom/client'

const domNode = document.getElementById('root')
const root = createRoot(domNode)
```

React will create a root for the `domNode`, and take over managing the DOM inside it. After you've created a root, you need to call [`root.render`](#root-render) to **display a React component inside of it**:

```js
root.render(<App />)
```

An app fully built with React will usually only have one `createRoot` call for its root component. A page that uses "sprinkles" of React for parts of the page may have as many separate roots as needed.

完全由 React 构建的应用通常只会对其根组件进行一次 createRoot 调用。而对于在页面的某些部分使用“sprinkles”（零星使用）React 的页面，可能会根据需要有多个独立的根节点。

> 动态挂载：如`message`，`modal`， `notification`

[See more examples below.](#usage)

#### Parameters

- `domNode`: A [DOM element.](https://developer.mozilla.org/en-US/docs/Web/API/Element) React will create a root for this DOM element and allow you to call functions on the root, such as `render` to display rendered React content.

- **optional** `options`: An object with options for this React root.

  - **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. React 自动从错误中恢复时调用的回调函数。
  - **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. React 在 useId 生成的 ID 中使用的字符串前缀。在同一页面上使用多个根时，这对于避免冲突非常有用。

#### Returns

`createRoot` returns an object with two methods: [`render(渲染)`](#root-render) and [`unmount(卸载)`.](#root-unmount)

#### Caveats

- If your app is server-rendered, using `createRoot()` is not supported. Use [`hydrateRoot()`](/reference/react-dom/client/hydrateRoot) instead.
- You'll likely have only one `createRoot` call in your app. If you use a framework, it might do this call for you.
- ✨When you want to render a piece of JSX in a different part of the DOM tree that isn't a child of your component (for example, a modal or a tooltip), use [`createPortal✨✨✨`](/reference/react-dom/createPortal) instead of `createRoot`. 当你想要在 DOM 树的不同部分渲染 JSX 片段时（例如，模态框或工具提示），请使用 `createPortal` 而不是 `createRoot`。
  > // TODO 尝试使用`createPortal`来渲染高德地图`marker`

---

### `root.render(reactNode)`

Call `root.render` to display a piece of [JSX](/learn/writing-markup-with-jsx) ("React node") into the React root's browser DOM node.

```js
root.render(<App />)
```

React will display `<App />` in the `root`, and take over managing the DOM inside it.

[See more examples below.](#usage)

#### Parameters

- `reactNode`: A _React node_ that you want to display. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [`createElement()`](/reference/react/createElement), a string, a number, `null`, or `undefined`.

#### Returns

`root.render` returns `undefined`.

#### Caveats

- The first time you call `root.render`, React will clear all the existing HTML content inside the React root before rendering the React component into it.第一次调用 root.render 时，React 会在将 React 组件渲染到根组件之前清除根组件内部的所有现有 HTML 内容。 -> 这里可以提前注入全局的 js 运行渲染前 loading 动画

- If your root's DOM node contains HTML generated by React on the server or during the build, use [`hydrateRoot()`](/reference/react-dom/client/hydrateRoot) instead, which attaches the event handlers to the existing HTML. 如果你的根 DOM 节点包含了在服务器端或构建过程中由 React 生成的 HTML，应该使用`hydrateRoot()`，它会将事件处理程序挂载到现有的 HTML 上。

- If you call `render` on the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by ["matching it up"](/learn/preserving-and-resetting-state) with the previously rendered tree. Calling `render` on the same root again is similar to calling the [`set` function](/reference/react/useState#setstate) on the root component: React avoids unnecessary DOM updates. 如果你在同一个根上多次调用`render`，React 会根据需要更新 DOM，以反映你传递的最新 JSX。React 会决定 DOM 的哪些部分可以被重用(React diff)，哪些需要通过与先前渲染的树进行"匹配"来重新创建。再次在同一个根上调用`render`类似于在根组件上调用`set`函数：React 避免不必要的 DOM 更新。

---

### `root.unmount()`

Call `root.unmount` to destroy a rendered tree inside a React root.调用 `root.unmount` 来销毁 React 根内部渲染的树。

```js
root.unmount()
```

An app fully built with React will usually not have any calls to `root.unmount`.
完全由 React 构建的应用**通常不会调用** `root.unmount`。

This is mostly useful if your React root's DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to "stop" managing the removed root's content by calling `root.unmount`. Otherwise, the components inside the removed root won't know to clean up and free up global resources like subscriptions.
这在你的 React 根 DOM 节点（或其任何祖先节点）可能会被其他代码从 DOM 中移除时非常有用。例如，想象一个 jQuery 选项卡面板，它会从 DOM 中移除不活动的选项卡。如果一个选项卡被移除，其中的所有内容（包括其中的 React 根）也会从 DOM 中移除。在这种情况下，你需要通过调用 `root.unmount` 告诉 React“停止”管理已移除根的内容。否则，移除根内部的组件将不知道如何清理和释放全局资源，比如订阅。

Calling `root.unmount` will unmount all the components in the root and "detach" React from the root DOM node, including removing any event handlers or state in the tree.
调用 `root.unmount` 将卸载根中的所有组件，并“分离”React 与根 DOM 节点的关联，包括移除树中的任何事件处理程序或状态。

#### Parameters

`root.unmount` does not accept any parameters.

#### Returns

`root.unmount` returns `undefined`.

#### Caveats

- Calling `root.unmount` will unmount all the components in the tree and "detach" React from the root DOM node.

- Once you call `root.unmount` you cannot call `root.render` again on the same root. Attempting to call `root.render` on an unmounted root will throw a "Cannot update an unmounted root" error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.一旦你调用了 `root.unmount`，就不能再在同一个根上调用 `root.render`。试图在已卸载的根上调用 `root.render` 将会抛出一个“Cannot update an unmounted root”错误。然而，在之前的根节点被卸载后，你可以为同一个 DOM 节点创建一个新的根。

---

## Usage

### Rendering an app fully built with React

If your app is fully built with React, create a single root for your entire app.

```js
import { createRoot } from 'react-dom/client'

const root = createRoot(document.getElementById('root'))
root.render(<App />)
```

Usually, you only need to run this code once at startup. It will:

1. Find the browser DOM node defined in your HTML.
2. Display the React component for your app inside.

**If your app is fully built with React, you shouldn't need to create any more roots, or to call [`root.render`](#root-render) again.**

From this point on, React will manage the DOM of your entire app. To add more components, [nest them inside the `App` component.](/learn/importing-and-exporting-components) When you need to update the UI, each of your components can do this by [using state.](/reference/react/useState) When you need to display extra content like a modal or a tooltip outside the DOM node, [render it with a portal.](/reference/react-dom/createPortal)
从这一点开始，React 将管理整个应用程序的 DOM。要添加更多组件，将它们嵌套在 App 组件内部。 当你需要更新 UI 时，每个组件都可以通过使用状态来实现。当你需要在 DOM 节点之外显示额外的内容，比如**模态框**或**工具提示**时，使用 portal 进行渲染。

<Note>

When your HTML is empty, the user sees a blank page until the app's JavaScript code loads and runs:

```html
<div id="root"></div>
```

This can feel very slow! To solve this, you can generate the initial HTML from your components [on the server or during the build.](/reference/react-dom/server) Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommend [using a framework](/learn/start-a-new-react-project#production-grade-react-frameworks) that does this optimization out of the box. Depending on when it runs, this is called _server-side rendering (SSR)_ or _static site generation (SSG)._
这可能会感觉非常慢！为了解决这个问题，你可以在服务器端或构建过程中从你的组件中生成初始 HTML。然后，你的访问者可以在任何 JavaScript 代码加载之前阅读文本、查看图片和点击链接。我们建议使用一个框架来自动进行这种优化。根据运行的时间点，这被称为服务器端渲染（SSR）或静态站点生成（SSG）。

</Note>

<Pitfall>

**Apps using server rendering or static generation must call [`hydrateRoot`](/reference/react-dom/client/hydrateRoot) instead of `createRoot`.** React will then _hydrate_ (reuse) the DOM nodes from your HTML instead of destroying and re-creating them.
**使用服务器渲染或静态生成的应用程序必须调用`hydrateRoot`而不是`createRoot`**。 然后，React 将会对 DOM 节点进行*水合*（重用），而不是销毁和重新创建它们。

</Pitfall>

---

### Rendering a page partially built with React `部分使用` React 构建页面

If your page [isn't fully built with React](/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page), you can call `createRoot` multiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by calling [`root.render`.](#root-render)

Here, two different React components are rendered into two DOM nodes defined in the `index.html` file:

<Sandpack>

```html public/index.html
<!DOCTYPE html>
<html>
  <head>
    <title>My app</title>
  </head>
  <body>
    <nav id="navigation"></nav>
    <main>
      <p>This paragraph is not rendered by React (open index.html to verify).</p>
      <section id="comments"></section>
    </main>
  </body>
</html>
```

```js
import './styles.css'
import { createRoot } from 'react-dom/client'
import { Comments, Navigation } from './Components.js'

const navDomNode = document.getElementById('navigation')
const navRoot = createRoot(navDomNode) // 挂载到多个节点
navRoot.render(<Navigation />)

const commentDomNode = document.getElementById('comments')
const commentRoot = createRoot(commentDomNode) // 挂载到多个节点
commentRoot.render(<Comments />)
```

```js
export function Navigation() {
  return (
    <ul>
      <NavLink href="/">Home</NavLink>
      <NavLink href="/about">About</NavLink>
    </ul>
  )
}

function NavLink({ href, children }) {
  return (
    <li>
      <a href={href}>{children}</a>
    </li>
  )
}

export function Comments() {
  return (
    <>
      <h2>Comments</h2>
      <Comment
        text="Hello!"
        author="Sophie"
      />
      <Comment
        text="How are you?"
        author="Sunil"
      />
    </>
  )
}

function Comment({ text, author }) {
  return (
    <p>
      {text} — <i>{author}</i>
    </p>
  )
}
```

```css
nav ul {
  padding: 0;
  margin: 0;
}
nav ul li {
  display: inline-block;
  margin-right: 20px;
}
```

</Sandpack>

You could also create a new DOM node with [`document.createElement()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) and add it to the document manually.

```js
const domNode = document.createElement('div')
const root = createRoot(domNode)
root.render(<Comment />)
document.body.appendChild(domNode) // You can add it anywhere in the document
```

To remove the React tree from the DOM node and clean up all the resources used by it, call [`root.unmount`.](#root-unmount)

```js
root.unmount()
```

This is mostly useful if your React components are inside an app written in a different framework.

---

### Updating a root component 更新 root 节点

You can call `render` more than once on the same root. As long as the component tree structure matches up with what was previously rendered, React will [preserve the state.](/learn/preserving-and-resetting-state) Notice how you can type in the input, which means that the updates from repeated `render` calls every second in this example are not destructive:
你可以在同一个根上多次调用`render`。只要组件树结构与先前渲染的内容匹配，React 就会保留状态。 请注意，你可以在输入框中输入文字，这意味着在这个例子中每秒重复调用`render`并不会破坏输入框中的内容。

<Sandpack>

```js src/index.js active
import { createRoot } from 'react-dom/client'
import './styles.css'
import App from './App.js'

const root = createRoot(document.getElementById('root'))

let i = 0
setInterval(() => {
  root.render(<App counter={i} />)
  i++
}, 1000)
```

```js src/App.js
export default function App({ counter }) {
  return (
    <>
      <h1>Hello, world! {counter}</h1>
      <input placeholder="Type something here" />
    </>
  )
}
```

</Sandpack>

It is uncommon to call `render` multiple times. Usually, your components will [update state](/reference/react/useState) instead.一般采用更新状态来保持组件达到最新

---

## Troubleshooting

### I've created a root, but nothing is displayed

Make sure you haven't forgotten to actually _render_ your app into the root:

```js {5}
import { createRoot } from 'react-dom/client'
import App from './App.js'

const root = createRoot(document.getElementById('root'))
root.render(<App />)
```

Until you do that, nothing is displayed.

---

### I'm getting an error: "Target container is not a DOM element"

This error means that whatever you're passing to `createRoot` is not a DOM node.

If you're not sure what's happening, try logging it:

```js {2}
const domNode = document.getElementById('root')
console.log(domNode) // ???
const root = createRoot(domNode)
root.render(<App />)
```

For example, if `domNode` is `null`, it means that [`getElementById`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) returned `null`. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:

1. The ID you're looking for might differ from the ID you used in the HTML file. Check for typos!
2. Your bundle's `<script>` tag cannot "see" any DOM nodes that appear _after_ it in the HTML.

Another common way to get this error is to write `createRoot(<App />)` instead of `createRoot(domNode)`.

---

### I'm getting an error: "Functions are not valid as a React child."✨

This error means that whatever you're passing to `root.render` is not a React component.这意味着你传递给`root.render`的参数不是一个 react 组件

This may happen if you call `root.render` with `Component` instead of `<Component />`:

```js {2,5}
// 🚩 Wrong: App is a function, not a Component.
root.render(App)

// ✅ Correct: <App /> is a component.
root.render(<App />)
```

Or if you pass a function to `root.render`, instead of the result of calling it:

```js {2,5}
// 🚩 Wrong: createApp is a function, not a component.
root.render(createApp)

// ✅ Correct: call createApp to return a component.
root.render(createApp())
```

---

### My server-rendered HTML gets re-created from scratch

> 服务端渲染必须使用`hydrateRoot`

If your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling `root.render` deletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.

Server-rendered apps must use [`hydrateRoot`](/reference/react-dom/client/hydrateRoot) instead of `createRoot`:

```js {1,4-7}
import { hydrateRoot } from 'react-dom/client'
import App from './App.js'

hydrateRoot(document.getElementById('root'), <App />)
```

Note that its API is different. In particular, usually there will be no further `root.render` call.
