# 模板编译

模板编译最重要的目标是生成渲染函数，而渲染函数的作用就是每次执行它，它就会使用当前最新的状态生成一份新的 VNode，然后使用这个 VNode 进行渲染。

模板编译分为三部分内容：

- 将模板解析为 AST： -> 解析器
- 遍历 AST 标记静态节点：->优化器
- 使用 AST 生成渲染函数：-> 代码生成器

## 解析器

> 将模板解析成 AST

在解析器内部，分成很多小的解析器，其中包括过滤解析器、文本解析器和 HTML 解析器。然后通过一条主线将这些解析器组装到一起。

- 文本解析器：解析带变量的的文本
- html 解析器：最核心的模块，每当解析到 HTML 标签的开始位置、结束位置、文本或者注释时，都会触发钩子函数，然后将相关参数传递出来。

主线上做的事情，就是监听 HTML 解析器，每当触发钩子函数时，就生成一个对应的 AST 节点。生成 AST 前，会根据类型使用不同的方式生成不同的 AST，AST 与 VNode 类型，都是使用 JavaScript 对象来表示。

## 优化器

遍历 AST，找出所有静态子树(永远都不会发发生变化的 DOM 节点)并给其打标记。

当 AST 中的静态子树被打上标记后，每次重新渲染时，就不需要为打上标记的静态节点创建新的虚拟节点，而是直接克隆已存在的虚拟节点。在虚拟 DOM 的更新操作中，如果发现两个节点是同一个节点，正常情况下会对这两个节点进行更新，但是如果这两个节点是静态节点，则可以直接跳过更新节点的流程。

## 代码生成器

将 AST 转换成渲染函数中的内容，这个内容可以成为"代码字符串"。

例如一个简单的模板：
`<p title="Berwin" @click="c">1</p>`

生成的代码：
`with(this){return _c('p', {attr:{title:"Berwin"}, on:{click: c}}, [_v('1')])}`

这个代码字符串最终导出到外界使用时，会将代码字符串放到函数里，这个函数叫做渲染函数。

````JS
const code = `with(this){return _c('p', {attr:{title:"Berwin"}, on:{click: c}}, [_v('1')])}`
const fn = new Function(code)
const vnode = fn()
```
````
