## 跨端引擎团队做了什么

通过`C++`给`v8`、`JavaScript core`拓展`api`，这些`api`由`Android`、`iOS`分别实现，包括渲染`DOM`和`CSS`，使用各种设备能力的`api`。

因为给予`JS`引擎实现了`W3C`标准的`DOM API`和`CSS`，那跨端引擎上就可以跑`HTML`、`CSS`、`JS`代码，通过他们组织逻辑，然后由`native`实现渲染和交互。

这之上还有一个类似`react`的前端框架(`rax`?)。最终渲染用的`DOM api`是跨端引擎提供的那些。

这个跨端引擎上跑的代码是有自己的一套规范的，业务线写代码会用 `less`、`typescript`、`es next` 等语言，然后转成**跨端引擎支持的写法**，所以需要**自研编译器**来做这种转换。

我们基于 `babel`、`less compiler` 实现了编译器，**递归的分析依赖，编译每一个文件**，然后打包到一起。我们并不需要 webpack 一样的 chunk 分组，因为不是浏览器平台，只需要压缩到一块就行。打包的产物是一个**二进制文件，叫做 bundle**。

编译只是让源代码能够在跨端引擎上跑起来，但跑起来之后会有**日志**、**报错**等信息，会需要做 **`dom`**、**`css` 的调试**、 **js 的 debugger** 等，这就需要**自研调试工具**，我们基于 **chrome devtools protocol** 实现了自己的调试工具。

编译、调试都是和写代码强相关的，所以又基于 `vscode` 定制了 `ide`，集成**自研编译器**、**自研调试工具**等，也实现了很多写代码相关的 **vscode 插件**，比如**路径提示**，j**s、css 的智能提示**等，因为**跨端引擎支持的样式**和 **js api** 都是不一样的，需要自己实现。

跨端引擎上的代码是一个个 `bundle` 的形式存在的，而 `bundle` 和 `bundle` 之间会有依赖，因为运行平台是自研跨端引擎，不支持 `node_modules` 那一套，所以自研了**依赖管理工具**。包括通过一个 `bundle.json` 声明依赖，**递归的下载依赖，全局的缓存**等。

此外，跨端引擎提供的各种 `api` 对于 `C++`、`Android`、`iOS`、文档都要保持统一，怎么保证统一呢？我们是通过 `ts` 作为 `dsl` 来描述文档和接口，然后编译成 `java`、`oc`、`markdown` 等，通过这种方式完成了**多端 api 还有文档的的统一、可编译**。

除了这些，还有**依赖分析工具**，分析所有跨端引擎相关的源代码，包括`Android`、`iOS`、`C++`、`js` 代码，提取各种数据供分析。

跨端引擎是 `C++`、`Android`、`iOS` 负责维护的，而**编译器**、**ide**、**调试工具**、**依赖管理工具**、**多端 api 和文档统一工具**、**依赖分析工具**都是我们前端同学维护的。

## 做了啥

**扩展 js 引擎**、**源码到源码的编译**、**ts 转多端代码和文档**、**依赖分析**等都和编译技术强相关，这一年我在前端领域的编译技术方面的提升特别大。

### 编译器的 sourcemap 的统一

之前编译的每一步都是割裂的，也就是每一步都是 `js/ts` 代码 `parse` 成 `AST`，转换成新的 `AST`，再生成 `js` 代码和 `sourcemap` 这样来一遍，但没有对每一步产生的 `sourcemap` 做关联，这就导致了最终跑在跨端引擎的代码并不能通过 `sourcemap` 映射到源码。

我修改了整个编译流程，每一步都把 AST 传递下去，这样修改完一遍之后再生成 `sourcemap`，这时候的 `sourcemap` 就是能**映射到源码**的，可以直接调试源码。

### 依赖安装工具的升级

最初的依赖安装工具是分析 `bundle.json`，**递归解析依赖**然后下载到 `xxx_modules` 目录下，并没有做全局的缓存，这就导致一个依赖的多次下载耗时是一样的。而且我们会修改下载下来的依赖 bundle，多个项目的同个 bundle 需要分别做修改，不能只修改一份。

我做了**全局缓存**，第一次下载会把依赖缓存到全局目录，然后复制到本地，后续下载该依赖直接从缓存拿，提升下载速度。我做了依赖提升到父级目录，然后 **`link`到本地**，这样多个项目修改的是同一份 `bundle`。> pnpm ?

### css 的智能提示和颜色预览

跨端引擎支持的 `css` 是 `w3c` 标准的**子集**，而且也有不一样的地方，业务开发同学需要经常查文档，一不小心就写错了，受这些影响，写 `css` 的效率是不高的。

于是我做了编译器的 **css lint** 功能，可以在编译期间检查出错误，后来想，为什么不提前到写代码的时候呢？于是又做了一个 **vscode 插件**，基于 **`language service protocol` 实现了语言服务**，**支持 css 的提示**、**错误检查**、**hover 时展示文档**，这样免去了查文档。还做了一个颜色预览的插件，给我们支持的一些颜色常量直接展示颜色，比较直观。

> rust 插件这方面也做得很好

### api 和 文档生成工具的升级

我们是通过 `ts` 的 `namespace`、`module`、`function` 等语法描述接口，然后编译成 `java`、`oc`、`markdown` 等的文件来做多端 api 和文档统一的。我们做了一个命令行工具，**解析配置文件指定的 `ts`**，**对`AST`做一系列分析**，之后**生成各种代码和文档**。

我扩展了语法的支持，实现了 `enum`、`interface`、`class` 等语法的解析，使接口描述方式更多样。修改了`markdown`文档的格式，使之更易读。还做了本地预览功能，可以本地生成`markdown`来看效果，之前是不支持的。

## Reference

- [链接](https://juejin.cn/post/7021923242579329060)
