# 【转载】新技术学习不完全指北：以`Rust`为例

> [原文链接](https://juejin.cn/post/6898953413250252814)

## 充分的学习动机是持续学习的源动力

### 学习技术，特别是学习新的技术，是一个高失败率的活动

不知道多少次，我们停在安装项目依赖上，停在`Hello World`级别的尝鲜上。

**根本原因是缺乏充分的学习动机**

学习动机不是一个缥缈虚无的概念，最常见、最显著的一个学习动机就是——**工作需求**。

**工作需求**，是一个强烈的、持续性的、外部驱动的学习动机。**那些跟工作关联起来的技术，通常就是我们掌握得最扎实、构成我们核心技术能力的部分**。而那些跟工作关联程度弱的技术，则是最容易中途放弃的部分。

### 学习动机不够充分而过早放弃，是导致学习失败的重要诱因

除了工作需求以外，个人兴趣是学习动机的另一大来源。

**学习动机，跟感情一样，也需要培养**。混迹于各个技术社区，听听其他人如何宣传不同的技术，我们可以看到那些技术分别做出的承诺，如内存安全、类型安全、跨平台、高性能、易用性、可维护性等等。渐渐的，某些技术就在我们的心里种下了兴趣的种子。

得到种子以后，我们需要亲自浇灌培育这些兴趣，让它们更加充沛。在所有感兴趣的技术中，**去挖掘它们对我们现有工作的潜在价值**。即便**只是启发价值也好，我们需要让个人兴趣跟工作需求关联起来，如此可以得到更加持久的学习动机**。

以我对 `Rust` 的动机浇灌为例：

我的本职工作是前端开发，涉及许多前端框架设计和前端基础设施建设等工作。

当前的前端架构，只用 `JavaScript`/`TypeScript` 和 `Node.js` 等技术栈，已经有点捉襟见肘。比如，用 `JavaScript` 实现的 `Webpack` 在应付大型前端项目的编译和构建，性能达不到要求。Vue 作者尤小右尝试借助浏览器原生的模块加载管理去优化这个问题，即最近热门的 Vite。其中 Vite 就选择了 Figma CTO 用 Go 实现的高性能 JavaScript bundler and minifier——`esbuild`。
未来前端开发基础设施里将包含越来越多系统级编程语言加持的工具。毕竟 `V8`，`Node.js`，`Deno` 就包含大量 `C/C++`和`Rust`语言实现代码。一切能用`JS`实现的，就算终将用`JS`实现，那些性能敏感的部分，也会更晚用`JS`实现。

也就是说，纯 `JavaScript`/`TypeScript`/`Node.js`/`Deno` 的前端架构师，将来的岗位胜任力和技术竞争力，很可能弱于掌握了一门或多门系统级编程语言及其生态的同行。因此，有志于前端架构方向的同学，在 `C/C++`, `Go`, `Rust` 等语言中选一门或多门进行持续学习，对将来或有帮助。（看到这里，不知道有没有埋下兴趣的种子呢？）

用系统级编程语言可以优化前端基础设施，但是要设计一个好用的前端框架，还需要学习其它知识。特别是函数式编程（`FP`）、编程语言理论（`PLT`）和类型论（`Type Theory`）等。比如学习 `Haskell`，理解 `Monad`，掌握 `Algebraic-Effects`，熟悉 `Codata` 等概念。

基于上述工作背景，`Rust` 相比 `Go` 等语言的学习优先级得以凸显。

1、`Rust` 语言设计更加现代，它很好地吸收了函数式编程特性，如**模式匹配**，**代数数据类型**，**Trait**，默认 **Immutable** 等

2、`Rust` 团队来自 Mozilla，对 `WebAssembly` 相对来说有更友好的支持和更多的投入，在 现代浏览器上通过 `Wasm` 去运行 `Rust` 代码提升性能，对于特定的、复杂的 Web App 很有帮助。在《Rust and WebAssembly》一书中可以看到更多相关内容。

3、`Rust` 在 `Safe` 和 `Useful` 上取得了更好的平衡。

![安全性和实用性](../assets/image/634c5cd646934967a1b9708668c9c7d1_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp)

**安全性和实用性坐标**。有的语言（如 `Haskell`）是从安全性出发，在保证安全的情况下，增加 IO 能力，向实用性靠拢。而我们使用的大部分主流语言，则是从实用性出发，在保证足够的实用性的情况下，通过 `Type System` 等的约束方式，增加安全性。

安全但不实用 vs 实用但很危险。最终大家的目标都是，**既安全又实用**。

简单地说，`Rust` 编译器可以让我们对代码的内存安全、类型安全更加放心，从而敢于并且可以编写出功能更复杂的代码，而不必疲于跟内存问题做斗争，或者浪费大量时间去 debug。

通过以上分析，我为自己浇灌了学习 `Rust` 的强烈动机。通过 `Rust`，我有望获得更相比在 `JavaScript`/`TypeScript` 里更充沛的函数式特性实践经验，有机会编写高性能的前端基础设施去优化开发效率，有机会编写高性能的 wasm 模块优化 Web App 性能，有机会借鉴 `Rust` 语言设计思路去实现 `runtime` 小，无需 `GC` 的前端 `DSL` 等的各种可能性。

如此，学习 `Rust` 就跟我的工作内容产生了微妙的关联，创造了一个持续的学习动机来源。如果大家愿意，也可以通过类似的方式，去挖掘出学习一门新技术的强烈动机所在。

## 严肃学习是有效学习的核心部分

培养学习动机的根本目的，是为了让我们进入**严肃学习**的阶段。

很多同学的学习方式有一个重大问题，就是一直停留在培养学习动机的阶段。什么意思？

就是一直在看技术问答、小文章、技术视频以及参与一些线下聚会等，却没有考虑去官方网站里*安装工具*、_下载依赖_、_阅读文档_、_编写代码_、_调试问题_、*搜索答案*等。

技术社区是为了让我们从他人的技术宣传中获得学习的兴趣，获得学习的素材，但它们自身不等于**严肃学习**。

### 严肃学习是指通过权威的、一手的、经典的、系统化的学习材料进行学习的过程。

以 Rust 为例，**入门 Rust 的严肃学习过程**是，进入 [rust-lang.org](https://rust-lang.org) 官网，阅读首页里的基本信息，了解 Rust 给出的介绍和承诺，通过 GET STARTED 安装 Rust 和新建 hello world 项目，运行起来。

然后**进入 LEARN MORE**，官方文档指引我们去阅读 《The Rust Programming Language》书籍，于是我们乖乖阅读，做书里的练习题。不用等到看完这本书，我们又发现了的另一本书《Rust By Example》，放到阅读列表里。读完第一本，读第二本，以此类推。

这是属于严肃学习的过程，我们使用的材料，是官方权威发布的，是一手的，是系统化的，也是 Rust 当前的入门经典。_而我们在技术社区里看到的，许多是其他开发者基于这些严肃材料而产出的技术文章，性质上属于读后感。读后感不是一手的，不是权威的，不是体系化的，不是经典的，不属于严肃学习的材料_。

读后感 / 学习心得相比严肃材料，更简单和轻松一点，可以帮助我们建立对 Rust 等技术的初步印象和学习信心，但难以作为入门 Rust 的充分材料。包括这篇文章本身，也不属于严肃学习的范畴，而是一个激发学习动机的材料。

人脑是一个对信息来源很挑剔的器官，技术社区里混杂了很多八卦信息，它会轻视其中的少量干货。而读教科书、经典著作和论文等严肃内容时，大脑对信息的处理模式会切换成严肃学习的状态，更容易记住内容，并尝试去关联知识点。

那些停留在收藏夹里的严肃材料链接，是开启我们有效学习大门的钥匙，而在技术社区搜罗和收藏它们的过程，则是培养学习动机的阶段。

读了 100 篇读后感，起码要配合读一篇相关的严肃材料去升华和沉淀，去聚拢离散的知识点。

## 高强度间歇性是高效学习的秘诀

在具备了学习动机、准备好了严肃学习材料之后，下一步就是**规划学习时间**了。

**高强度间歇性训练方法**，原本是用以健身，现在我们借用来描述知识学习的一种时间规划策略。

**让学习更高效，本质上是让大脑非理性部分去重视理性认知的成果**。人类的理性认知能力，相比大脑的其它功能，比如视觉加工、记忆、语言等，是更晚演化出来的部分。因此，人类记忆的工作机制很大程度上是相对独立的，不是我们想记住什么就记住什么，想忘记什么就忘记什么。在我们具备理性思考的能力之前，我们已经具备记住信息的能力了。

因此，我们**需要利用人类的记忆偏好、对信息加工的偏好等各种既定特性，去让大脑记住我们理性上认定是重要的知识点**。通过严肃材料进行学习，一方面是保证内容的**正确性**和**系统性**，另一方面也是**诱导大脑去做深刻加工**。

**严肃材料**对我们的大脑来说，有两重意义。一个是客观层面，学习材料由权威人士编写，经过了层层的检验和时间的考验。一个是主观层面，学习材料对我很重要，很有意义，关系很大。

找到严肃材料之后，只达成了第一个层面的严肃性。第二层面的严肃性，需要我们自我建设。世界上的严肃材料这么多，如何向我们的大脑证明眼前这一堆确实是严肃的、重要的材料呢？

一个有效途径是，让这些材料反复出现，即**高频次**、**高密度**、**高强度**地出现。

**每天规划出一段时间，半小时到两小时左右**，比如*我规划出晚上 10 点到 12 点之间学习 `Rust` 严肃材料*。_让 `Rust` 每天都出现在我面前，每天都暴露在我的脑海里，随着它出现时间和频次的增加，大脑自动会逐渐认可 `Rust` 对我的生活的重要性_。特别是，学习 `Rust` 过程中会遇到很多问题及其解决方案。它们会启动大脑的另一个认知偏好——对负面内容更敏感。也就是说，对我的大脑来说，每天都有 `Rust` 相关的问题在不断产生和解决，它会分配更多认知资源去处理和消化 `Rust` 知识，它会激发我们对 `Rust` 更有兴趣，因为它会想要获取更多 `Rust` 信息去加工。主观体验就是，我们会感到 `Rust` 越来越好玩。

### 高强度的持续信息暴露是必要的，**三天打鱼两天晒网**的学习方式，难以有效的激活大脑对 `Rust` 或其它技术的严肃定位。

除了高强度部分以外，间歇性的部分也很重要。它是指，我们必须适时停下来，娱乐、休息和睡眠。尽量不要废寝忘食地啃学习材料，仿佛一天要学完整本书。这是不现实的，一天强行看完整本书，不代表学习了整本书。大脑需要在睡眠阶段对当天所学习的内容进行加工和整合。不停下来提供消化知识的机会，对身体健康和学习质量都没有帮助。

用**权威学习材料达成客观上的严肃性**，用**高强度间歇性训练思路达成主观上的严肃性**，两者结合起来，我们学到了主客观层面都靠得住的严肃知识。

即便不了解上述严肃学习策略，其实很多同学也已有意或无意的通过增加严肃性来优化学习过程。只不过其中很多策略，可能不太经得起推敲。比如报一个培训班，增加老师和同学的监督角色，来提升学习的严肃性；比如去自习室、星巴克等地方增加学习氛围的严肃性；比如购买实体书籍，布置一个富有仪式感的环境去学习等。

在短时间内，这些做法固然是提升了学习的严肃性和质量；但这不是免费的。这些形式上、氛围上的严肃性，可能是成本高昂的。比如，当我们购买了 Rust 实体书回来后，很直观的看到，它像砖头一样厚。

可能每次学习时，都得鼓起莫大的勇气，把厚厚的书籍翻出来。每次都要洗漱打扮，出门去自习室占座，或者去星巴克占座，然后才开启学习之旅。这种**启动学习的成本太高了**，很可能导致我们学不起来，大砖头书籍最后垫显示器去了。

我个人的选择是，**在线学习**。我的 `Chrome` 设置为每次打开都还原上一次关闭时打开的链接。`Rust` 材料的 `Tab` 标签页在我完成学习之前，会一直出现在我的浏览器中，只要我有了心思，可以迅速地切换 `Tab` 进入学习，迅速的启动 `VSCode` 编写和运行代码。

在制定学习规划时，我们需要明确有效学习的干货部分是否得到最优化：1）**我们找的学习材料里包含严肃的知识**；2）**我们成功让我们大脑认可了这些知识的严肃性，使我们能长时间记住它们。即严肃性的知识得到主客观的统一**。

**尽可能低成本地启动严肃学习，可能是更好的途径**。

> 1、增加学习时间；2、提高学习效率

## 超纲训练是巩固知识的可靠方式

找到严肃的学习材料，扎实且认真地学习了这些材料之后，下一个阶段是——**超纲训练**。

看过一遍书，不代表充分理解了书里的知识。我们要去证明自己确实在一定程度上领会了知识。

如何证明？

做那些没有参考答案的训练，即**超纲训练**。

以我学习 `Rust` 为例，《The Rust Programming Language》带领我们实现了一个简单的 grep cli 程序，一个简单的多线程 web server。但是，我们的代码实现，跟书里的答案太像了。即便我们能默写答案，也无法劝服我们的大脑，这些代码是我们的自主产出。

因此，在看完《The Rust Programming Language》和《Rust By Example》，我给自己安排了新的训练项目——**光线追踪**。

《[Ray Tracing in One Weekend](https://link.juejin.cn/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fraytracing.github.io%2Fbooks%2FRayTracingInOneWeekend.html)》是一本循序渐进的小书，里面的代码实现用的是 `C++`，我们可以用 `Rust` 做一个重新的实现。如此构成一个超纲训练，我们的代码有参考，但不是 `Rust` 代码，而是 `C++` 代码。我们需要完成三个层次的理解：1）理解光线追踪算法；2）理解 C++ 实现方式；3）使用 Rust 实现。

光线追踪是一个学习新语言特别好的训练项目，它能囊括多种语言特性，又有性能要求，而且主要是数学计算，最后输出的是数字构成的列表 / 数组，几乎不需要使用其它 API，可以在多种环境里使用。

用 Rust 实现光线追踪时用到的功能大致如下：

- 0）基础特性：变量，循环，基本控制流，模式匹配，数据结构，数值计算，模块，文件系统接口等
- 1）操作符重载：Vec3 向量数据结构的 +-\*/ 等运算需要重载。
- 2）Trait objects：多种类型的几何体，多种类型的材质，需要能够放到一个列表或者一个字段里做统一处理。
- 3）递归函数：光线追踪算法是一个在递归函数里不断产生新的光线路径的算法
- 4）包 / crate 的使用：rand 和 threadpool
- 5）性能优化：使用多线程优化光线追踪算法性能
- 6）单元测试
- 7）cli 参数读取
- 8）代码组织结构设计
- 9）……

基本上覆盖到了 Rust 核心语言特性的一大部分。

如此，我们完成了一个超纲训练，**这个过程肯定会遇到很多困惑和问题**，我们会反复翻看《The Rust Programming Language》和《Rust By Example》里的相关部分，查看 Rust 标准库文档，查看 crate 文档，Google 搜索其它问题等等。**正是这些问题以及我们追索答案的过程，巩固了我们看书时有意无意疏漏的部分**。

超纲训练是可以不断升级的，升级越多的层次，完成度和质量越高，训练效果则越好。当然训练难度也会不断增加，到某个程度后，我们自然会停下来。比如前面用*多线程优化光线追踪的部分*，就算一次升级，它是在《Ray Tracing in One Weekend》没有包含的部分。

另一个升级是，我们可以将 `Rust` 通过 `Wasm` 运行到浏览器上，然后对比 `JavaScript` 实现的光线追踪算法，看看两者的性能差异。这正符合我对 `Rust` 的学习动机之一：用 `Rust` + `Wasm` 优化浏览器里特定任务的性能表现。

因此，我开始阅读 `Rust` 官网里指引的另一本书《Rust and WebAssembly》，学习如何在浏览器里运行 `Rust` 代码，然后将我们的 `Rust` 光线追踪调整成 `library crate`。

其中 JavaScript 版本是我一年多前学习光线追踪算法时，所做的超纲训练项目。为此我还写了 3 篇文章，描述如何优化光线追踪的渲染表现：《React 优化技巧在 Web 版光线追踪里的应用：[上](https://juejin.cn/post/6909716626736676878)、[中](https://juejin.cn/post/6911508764063432712)和[下](https://juejin.cn/post/6913790120990769160)》，恰好可以拿来跟 `Rust` 对比性能表现。

目前我所做的超纲训练，就到上面为止了。其实还可以做更多升级，《Ray Tracing in One Weekend》的作者写的相关系列，一共有 3 本，还有另外两本的练习没有去做呢。即便都做完了，还是可以继续升级，将练习项目变成更加严肃的开源项目，成为一个 Rust 生态里的光线追踪 crate。都是可以的，但这不是我当前的目标，因此我还没有往这个方向努力的计划。总而言之，光线追踪作为我学习 Rust 的超纲训练，已经完成了它的使命。

超纲训练之所以重要，是因为**一旦我们将学习到的技术，投入生产。我们所面对的各种问题，几乎都是超纲的，再没有书里的参考答案让我们照抄了**(特别信服)。因此，在跟着官方书籍和教程学习完毕之后，立刻启动一个超纲项目加以巩固，可以有效提升学习的质量。

## 成果积累是获得技术自信的必要条件

一场学习之旅的最后一步，也是最容易被忽视的一步，就是将这次学习之旅汇聚成一个标志性的成果。

成果，可大可小。小到练习成果，大到科研成就。它是一个里程碑，昭示着某段时间的努力的价值。

它可以是一个具体的产物，也可以是一篇总结文章。当我们完成超纲训练时，其实已经自然而然得到了一个学习成果，当我们写成一篇文章时，又产生了另一个成果。尽管在将来的我们看来，这些成果实在微不足道，但是我们现在仍然需要一个成果。

我们的大脑需要一个成果性质的刺激。

**是什么，区分了一次成功的学习和中途放弃的失败学习？是成果**。

如前面所言，Rust 光线追踪还可以无限升级，根本学不到头。不管我做成怎样，本质上都是中途放弃了去无限升级难度。因此，我们要创造一个阶段性成果，去明确定义这次学习之旅是成功的，是达到预期的。上面那个托管在 Github 的 Demo 项目，以及这篇文章，都属于我这次学习 Rust 的阶段性成果。

随着我们学习的技术越来越多，我们累计的阶段性成果和文章也越来越多。我可以在 Rust 学习成果中，援引上次学习光线追踪的 JavaScript 版本的代码；可以在这篇文章中，援引上次我写的 3 篇文章。这些在时间长河中层叠和交织在一起的阶段性成果，可以告诉我们的大脑，它们真的很有用，很有价值，它们值得被铭记。

不断积累的成果，有大有小，有的可能已经被继续升级，甚至得到其他人的广泛认可，它们构成了你的成就。随着我们拥有的成果和成就的增加，我们的技术自信心也会增加，更容易启动去学习新的技术，去创造新的阶段性成果。

我们需要去保留成果，让它们留下痕迹，可举证。一旦我们知道，再也没有什么东西，可以证明我曾经学过和达成过某些目标和成果，我们的大脑可能不再认为它们对我们的生活是息息相关的。而如果我们一直记得，可以从哪里拿出某个材料，作为证据，昭示我们曾经的努力及其价值，我们的大脑会更乐意长时间的记住跟这个功勋章有关的知识。

_对于技术学习而言，放在 Github 里的仓库，是一个很好的成果储存媒介_。

## 心态建设是快乐学习的关键

学习技术，是一个长期的，甚至可能是终身学习的活动。在这个过程中，我们会碰到很多迷思，它们可能降低了我们学习的乐趣，可能打击了我们学习的自信心。如何抗住这些负面思绪，正确的看待学习中遇到的各种困惑，是我们需要长期努力的方向。

### 失败是学习的常态，成功才是罕见的

**很多学习是有前置知识要求的**，在满足这些要求之前，越级去攻克某些知识，事倍功半，失败是很显然的。但是，很多时候，我们实在是不知道我们要学习的内容，究竟有什么前置要求，我究竟是否具备这些条件。我们只能亲自学上一学，用实际行动去检验我现在究竟有没有学会这些技术的资质。

也就是说，开启学习之旅，本身就是一场未知的冒险。学习失败，不完全是负面信号，不是指我们彻底完蛋了，它反而提供了很多**正面线索**：1）这些材料不适合我的情况；2）我需要寻找其它材料；3）我需要过一段时间，有了其它积累，再试试。

及时停止低质量的，甚至无效的学习，是在止损，是在保留精力，投资在更有回报的学习中去。不必气馁，来日方长。下一回，我们卷土重来时，胜算更高。

我们去积累成功，但不必去细数失败，徒增伤心，打击士气。

### 不必盲目攀比学习效率

严肃学习需要减少偷懒成分，去扎实的、诚恳的、谦卑的阅读系统化的材料吧，最后它们会给我们带来不可估量的价值。

不要去思考我是不是足够有学习效率，是否比别人学习效率高，转而思考，我是否在忠实地学习？

我们不知道在学习初期的加速行为，**是否导致了后续学习效率的变慢**。我们不能盲目的加快入门速度，因为对于我们还不了解的技术，我们实在难以评估后果。有时看似愚笨的默默学习，或许反倒让我们后续的学习之路更加通畅。

**严肃而诚恳地学习，即便不是最佳学习策略，也是一个明显不坏的选择**。

### 不必成为焦虑的学习机器

人的成长曲线，可能是间歇性的突飞猛进，加上长时间的停滞甚至退步，构成的涨落。一年能完成一两次高质量的严肃学习，已经非常可观了。

去安然地享受看似不思进取的娱乐时光吧，然后认真对待每一次严肃学习的机遇
