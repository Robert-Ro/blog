# FreeWheel npm 发版分享

> [来源](https://time.geekbang.org/column/article/576751)

在 JS 的整个生态里，最重要的一个中间产物就是 NPM 包，我们就可以把这些项目发布成 NPM。发布 NPM 包也有几个阶段，一开始是靠人工，这还是很痛苦的。

不仅要确保有权限，然后发布包时还要去给包打 Tag，提交到 Git 上。如果忘了打，到时候还得补上，最后经常出现补着补着补错了的情况。说句题外话，人会出错，这是一定的，因此也没必要去苛责这个人。换句话说，本来就应该是自动化做的事情，就不要让人一直去做，因为他终有一天会出错。

到后来我们改进为在持续集成里去发 NPM 包，也就是自动化的方式。Conventional commits，意思是说在你的 git commit message 里，我们可以用一些约定俗成的方式，比如说 feat，然后再在后面加一些描述。如果说你有 Breaking Change（破坏性更新），你就加一行 Breaking Change。

后面还会有一些描述，当这个东西进去以后，比如说如果只有 feat，会帮我们去做一个小版本的更新。假设之前是 1.2.3，现在变成 1.3.0。如果我有 Breaking Change，我就告诉 Commit 说是有 Breaking Change，最后就会变成 2.0.0 发布。

同时，CI 也会在 Jenkins 里面去跑，每次也会探测和判断一下，检查一下我都有哪些 Change，是不是需要发包，甚至如果完全没有 Change ，就直接跳过。当然，在发包之前肯定要过 Lint 和 Test。如果我们现在的分支属于 main 分支，我发的就是正式版本，比如 1.1.0。但如果我现在是一个 next 分支 ，就会发一个 pre-release 版本，比如 1.2.0-alpha.0，类似这样的。

甚至，当我发完包以后 ，lerna 会帮我们自动创建一个 Git 的 tag，把这个 tag，还有 commit 都提交上去。提交进去以后，我们还要根据当时的 main 分支去重新创建一个 next 分支出来，保证我下次再合并 next 分支时不会出现太大的冲突。这套机制在我们公司用得还是蛮舒服的，帮助我们解决了很多问题。

这样一来，无论是业务团队还是我们得兄弟团队，当有新版本发布的时候，只要去看新版本，装到自己的项目里就可以了，当然也可以选择不装。

总结来说，通过 CI/CD 的方式提高了我们工程实践上的效率，也是比较革命性的一个事情了。当然，我们还是借助了外面的工具，也发现无论是 Webpack 还是后来的 NPM 包，它们都是有极限的。

> 内部业务向的库存在这个问题，开源库倒是有明确的版本变更计划
