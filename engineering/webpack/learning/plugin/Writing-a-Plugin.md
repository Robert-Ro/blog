# Writing a Plugin

## Creating a Plugin

A plugin for webpack consists of:

- A named JavaScript function or a JavaScript class.
- Defines `apply` method in its prototype.
- Specifies an [event hook](https://webpack.js.org/api/compiler-hooks/) to tap into.
- Manipulates webpack internal instance specific data.
- Invokes webpack provided callback after functionality is complete.

example:

```js
// A JavaScript class.
class MyExampleWebpackPlugin {
  // Define `apply` as its prototype method which is supplied with compiler as its argument
  apply(compiler) {
    // Specify the event hook to attach to
    compiler.hooks.emit.tapAsync('MyExampleWebpackPlugin', (compilation, callback) => {
      console.log('This is an example plugin!')
      console.log('Here’s the `compilation` object which represents a single build of assets:', compilation)

      // Manipulate the build using the plugin API provided by webpack
      compilation.addModule(/* ... */)

      callback()
    })
  }
}
```

## Async event hooks

Some plugin hooks are asynchronous. To tap into them, we can use `tap` method which will behave in synchronous manner or use one of `tapAsync` method or `tapPromise` method which are asynchronous methods.

### tapSync

When we use `tapAsync` method to tap into plugins, we need to call the callback function which is supplied as the last argument to our function.

```js
class HelloAsyncPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapAsync('HelloAsyncPlugin', (compilation, callback) => {
      // Do something async...
      setTimeout(function () {
        console.log('Done with async work...')
        callback()
      }, 1000)
    })
  }
}

module.exports = HelloAsyncPlugin
```

### tapPromise

When we use `tapPromise` method to tap into plugins, we need to return a promise which resolves when our asynchronous task is completed.

```js
class HelloAsyncPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapPromise('HelloAsyncPlugin', (compilation) => {
      // return a Promise that resolves when we are done...
      return new Promise((resolve, reject) => {
        setTimeout(function () {
          console.log('Done with async work...')
          resolve()
        }, 1000)
      })
    })
  }
}

module.exports = HelloAsyncPlugin
```

### Full Example

```js
class FileListPlugin {
  static defaultOptions = {
    outputFile: 'assets.md',
  }

  // Any options should be passed in the constructor of your plugin,
  // (this is a public API of your plugin).
  constructor(options = {}) {
    // Applying user-specified options over the default options
    // and making merged options further available to the plugin methods.
    // You should probably validate all the options here as well.
    this.options = { ...FileListPlugin.defaultOptions, ...options }
  }

  apply(compiler) {
    const pluginName = FileListPlugin.name

    // webpack module instance can be accessed from the compiler object,
    // this ensures that correct version of the module is used
    // (do not require/import the webpack or any symbols from it directly).
    const { webpack } = compiler

    // Compilation object gives us reference to some useful constants.
    const { Compilation } = webpack

    // RawSource is one of the "sources" classes that should be used
    // to represent asset sources in compilation.
    const { RawSource } = webpack.sources

    // Tapping to the "thisCompilation" hook in order to further tap
    // to the compilation process on an earlier stage.
    compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
      // Tapping to the assets processing pipeline on a specific stage.
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,

          // Using one of the later asset processing stages to ensure
          // that all assets were already added to the compilation by other plugins.
          stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
        },
        (assets) => {
          // "assets" is an object that contains all assets
          // in the compilation, the keys of the object are pathnames of the assets
          // and the values are file sources.

          // Iterating over all the assets and
          // generating content for our Markdown file.
          const content =
            '# In this build:\n\n' +
            Object.keys(assets)
              .map((filename) => `- ${filename}`)
              .join('\n')

          // Adding new asset to the compilation, so it would be automatically
          // generated by the webpack in the output directory.
          compilation.emitAsset(this.options.outputFile, new RawSource(content))
        }
      )
    })
  }
}

module.exports = { FileListPlugin }
```

This will generate a markdown file with chosen name that looks like this:

```md
# In this build:

- main.css
- main.js
- index.html
```

## Different Plugin Shapes

A plugin can be classified into types based on the event hooks it taps into. Every event hook is pre-defined as synchronous or asynchronous or waterfall or parallel hook and hook is called internally using `call`/`callAsync` method. The list of hooks that are supported or can be tapped into is generally specified in `this.hooks` property.

For example:

```js
this.hooks = {
  shouldEmit: new SyncBailHook(['compilation']),
}
```

It represents that the only hook supported is `shouldEmit` which is a hook of `SyncBailHook` type and the only parameter which will be passed to any plugin that taps into `shouldEmit` hook is `compilation`.

Various types of hooks supported are :

### Synchronous Hooks

- SyncHook
- Bail Hooks
- Waterfall Hooks

### Asynchronous Hooks

- Async Series Hook
- Async waterfall
- Async Series Bail
- Async Parallel

## Resources

- [webpack contribute: writing-a-plugin](https://webpack.js.org/contribute/writing-a-plugin/)
- [webpack tapable](https://github.com/webpack/tapable)
- [compiler-hooks](https://webpack.js.org/api/compiler-hooks/)

## 实践

- 字体简化插件
